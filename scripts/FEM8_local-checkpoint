{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import random as pyrandom\n",
    "import sys, os\n",
    "nb_dir = os.path.split(os.getcwd())[0]\n",
    "if nb_dir not in sys.path:\n",
    "    sys.path.append(nb_dir)\n",
    "from parse_input import *\n",
    "\n",
    "import logging\n",
    "\n",
    "def setup_custom_logger(name):\n",
    "    formatter = logging.Formatter(fmt='%(asctime)s [%(levelname)-8s] %(message)s',\n",
    "                                  datefmt='%Y-%m-%d %H:%M:%S')\n",
    "    handler = logging.FileHandler('log.txt', mode='w')\n",
    "    handler.setFormatter(formatter)\n",
    "    screen_handler = logging.StreamHandler(stream=sys.stdout)\n",
    "    screen_handler.setFormatter(formatter)\n",
    "    logger = logging.getLogger(name)\n",
    "    logger.setLevel(logging.DEBUG)\n",
    "    logger.addHandler(handler)\n",
    "    logger.addHandler(screen_handler)\n",
    "    return logger\n",
    "\n",
    "logger = setup_custom_logger('parabola')\n",
    "\n",
    "# atoms.txt Содержит информацию об атомах, в колонках следующие данные:\n",
    "# ID, x, y, z, сигма, эпсилон, заряд, \n",
    "# радиус Ван-дер-Ваальса, объём и еще две колонки типа строки; \n",
    "# радиус и объем и эти две колонки не используются далее\n",
    "atoms = rd('atoms.txt', 1, 9)  # вместо 9 можно было и 7 взять\n",
    "\n",
    "# bonds.txt Содержит информацию о связях, структура файла:\n",
    "# ID1, ID2, Kr, r0\n",
    "bonds = rd('bonds.txt', 2)\n",
    "\n",
    "# angles.txt Содержит информацию об углах, структура файла:\n",
    "# ID1, ID2, ID3, Kt, theta0\n",
    "angles = rd('angles.txt', 3)\n",
    "\n",
    "# dihedrals.txt Содержит информацию о двугранных углах, структура:\n",
    "# ID1, ID2, ID3, ID4, V1, V2, V3, V4\n",
    "# Все константы V1, V2, V3, V4 разделены на два, \n",
    "# при вычислении энергии делить их на два НЕ НАДО.\n",
    "dihedrals = rd('dihedrals.txt', 4)\n",
    "\n",
    "# neighbours.txt, two_bonds_neigh.txt, three_bonds_neigh.txt\n",
    "# Содержат информацию о соседях непосредственных, \n",
    "# второго и третьего порядка соответственно. \n",
    "# У всех одна и та же структура:\n",
    "# ID    id_1 id_2 ... id_n\n",
    "# ID – индекс атома, id_1 id_2 ... id_n – индексы его соседей.\n",
    "neighbours = rd('neighbours.txt')\n",
    "two_bonds_neigh = rd('two_bonds_neigh.txt')\n",
    "\n",
    "three_bonds_neigh = rd('three_bonds_neigh.txt')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib notebook\n",
    "from sklearn.cluster import DBSCAN\n",
    "from sklearn import metrics\n",
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.cm as cmx\n",
    "import matplotlib\n",
    "\n",
    "colorsMap='jet'\n",
    "cm = plt.get_cmap(colorsMap)\n",
    "scalarMap = cmx.ScalarMappable(cmap=cm)\n",
    "\n",
    "dt = np.array([[coor[1], coor[2], coor[3]] for coor in atoms])\n",
    "# Compute DBSCAN eps=1.6, min_samples=5 eucl\n",
    "# manh eps=3, min_samples=5\n",
    "\n",
    "db = DBSCAN(eps=2.165, min_samples=7, metric='euclidean', algorithm='kd_tree').fit(dt)\n",
    "core_samples_mask = np.zeros_like(db.labels_, dtype=bool)\n",
    "core_samples_mask[db.core_sample_indices_] = True\n",
    "labels = db.labels_\n",
    "\n",
    "# Number of clusters in labels, ignoring noise if present.\n",
    "n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)\n",
    "\n",
    "print('Estimated number of clusters: %d' % n_clusters_)\n",
    "# print(\"Homogeneity: %0.3f\" % metrics.homogeneity_score(labels_true, labels))\n",
    "# print(\"Completeness: %0.3f\" % metrics.completeness_score(labels_true, labels))\n",
    "# print(\"V-measure: %0.3f\" % metrics.v_measure_score(labels_true, labels))\n",
    "# print(\"Adjusted Rand Index: %0.3f\"\n",
    "#       % metrics.adjusted_rand_score(labels_true, labels))\n",
    "# print(\"Adjusted Mutual Information: %0.3f\"\n",
    "#       % metrics.adjusted_mutual_info_score(labels_true, labels))\n",
    "# print(\"Silhouette Coefficient: %0.3f\"\n",
    "#       % metrics.silhouette_score(X, labels))\n",
    "\n",
    "xs = dt[:, 0]\n",
    "ys = dt[:, 1]\n",
    "zs = dt[:, 2]\n",
    "print(labels)\n",
    "\n",
    "#lbl = [0] * len(labels)\n",
    "#lbl[684] = 1\n",
    "fig = plt.figure(figsize=(10, 9))\n",
    "ax = Axes3D(fig, rect=[0, 0, .95, 1], elev=48, azim=134)\n",
    "ax.set_xlabel('x')\n",
    "ax.set_ylabel('y')\n",
    "ax.set_zlabel('z')\n",
    "ax.scatter3D(xs, ys, zs, c=scalarMap.to_rgba(labels))\n",
    "# fig.show()\n",
    "\n",
    "# plt.figure(figsize=(14, 9))\n",
    "# plt.scatter(xs, ys, c=labels)\n",
    "# #plt.interactive(True)\n",
    "# plt.show()\n",
    "\n",
    "# plt.figure(figsize=(14, 9))\n",
    "# plt.scatter(ys, zs, c=labels)\n",
    "# plt.show()\n",
    "\n",
    "# plt.figure(figsize=(14, 9))\n",
    "# plt.scatter(xs, zs, c=labels)\n",
    "# plt.show()\n",
    "\n",
    "# # #############################################################################\n",
    "\n",
    "# # Black removed and is used for noise instead.\n",
    "unique_labels = set(labels)\n",
    "colors = [plt.cm.Spectral(each)\n",
    "          for each in np.linspace(0, 1, len(unique_labels))]\n",
    "plt.figure(figsize=(10, 9))\n",
    "#ax = Axes3D(fig, rect=[0, 0, .95, 1], elev=48, azim=134)\n",
    "for k, col in zip(unique_labels, colors):\n",
    "    if k == -1:\n",
    "        # Black used for noise.\n",
    "        col = [0, 0, 0, 1]\n",
    "\n",
    "    class_member_mask = (labels == k)\n",
    "\n",
    "    xy = dt[class_member_mask & core_samples_mask]\n",
    "    plt.plot(xy[:, 0], xy[:, 1], 'o', markerfacecolor=tuple(col),\n",
    "             markeredgecolor='k', markersize=14)\n",
    "\n",
    "    xy = dt[class_member_mask & ~core_samples_mask]\n",
    "    plt.plot(xy[:, 0], xy[:, 1], 'o', markerfacecolor=tuple(col),\n",
    "             markeredgecolor='k', markersize=6)\n",
    "\n",
    "plt.title('Estimated number of clusters: %d' % n_clusters_)\n",
    "#ax.scatter(xy[:, 0], xy[:, 1], xy[:, 0], c = labels)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib\n",
    "from sklearn.cluster import DBSCAN\n",
    "from sklearn import metrics\n",
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.cm as cmx\n",
    "import matplotlib\n",
    "\n",
    "colorsMap='jet'\n",
    "cm = plt.get_cmap(colorsMap)\n",
    "scalarMap = cmx.ScalarMappable(cmap=cm)\n",
    "\n",
    "dt = np.array([[coor[1], coor[2], coor[3]] for coor in atoms])\n",
    "# Compute DBSCAN eps=1.6, min_samples=5 eucl\n",
    "# manh eps=3, min_samples=5\n",
    "\n",
    "db = DBSCAN(eps=2.165, min_samples=7, metric='euclidean', algorithm='kd_tree').fit(dt)\n",
    "core_samples_mask = np.zeros_like(db.labels_, dtype=bool)\n",
    "core_samples_mask[db.core_sample_indices_] = True\n",
    "labels = db.labels_\n",
    "\n",
    "# Number of clusters in labels, ignoring noise if present.\n",
    "n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)\n",
    "\n",
    "print('Estimated number of clusters: %d' % n_clusters_)\n",
    "# print(\"Homogeneity: %0.3f\" % metrics.homogeneity_score(labels_true, labels))\n",
    "# print(\"Completeness: %0.3f\" % metrics.completeness_score(labels_true, labels))\n",
    "# print(\"V-measure: %0.3f\" % metrics.v_measure_score(labels_true, labels))\n",
    "# print(\"Adjusted Rand Index: %0.3f\"\n",
    "#       % metrics.adjusted_rand_score(labels_true, labels))\n",
    "# print(\"Adjusted Mutual Information: %0.3f\"\n",
    "#       % metrics.adjusted_mutual_info_score(labels_true, labels))\n",
    "# print(\"Silhouette Coefficient: %0.3f\"\n",
    "#       % metrics.silhouette_score(X, labels))\n",
    "\n",
    "xs = dt[:, 0]\n",
    "ys = dt[:, 1]\n",
    "zs = dt[:, 2]\n",
    "print(labels)\n",
    "\n",
    "#lbl = [0] * len(labels)\n",
    "#lbl[684] = 1\n",
    "fig = plt.figure(figsize=(10, 9))\n",
    "ax = Axes3D(fig, rect=[0, 0, .95, 1], elev=48, azim=134)\n",
    "ax.set_xlabel('x')\n",
    "ax.set_ylabel('y')\n",
    "ax.set_zlabel('z')\n",
    "ax.scatter3D(xs, ys, zs, c=scalarMap.to_rgba(labels))\n",
    "# fig.show()\n",
    "\n",
    "# plt.figure(figsize=(14, 9))\n",
    "# plt.scatter(xs, ys, c=labels)\n",
    "# #plt.interactive(True)\n",
    "# plt.show()\n",
    "\n",
    "# plt.figure(figsize=(14, 9))\n",
    "# plt.scatter(ys, zs, c=labels)\n",
    "# plt.show()\n",
    "\n",
    "# plt.figure(figsize=(14, 9))\n",
    "# plt.scatter(xs, zs, c=labels)\n",
    "# plt.show()\n",
    "\n",
    "# # #############################################################################\n",
    "\n",
    "# # Black removed and is used for noise instead.\n",
    "unique_labels = set(labels)\n",
    "colors = [plt.cm.Spectral(each)\n",
    "          for each in np.linspace(0, 1, len(unique_labels))]\n",
    "plt.figure(figsize=(10, 9))\n",
    "#ax = Axes3D(fig, rect=[0, 0, .95, 1], elev=48, azim=134)\n",
    "for k, col in zip(unique_labels, colors):\n",
    "    if k == -1:\n",
    "        # Black used for noise.\n",
    "        col = [0, 0, 0, 1]\n",
    "\n",
    "    class_member_mask = (labels == k)\n",
    "\n",
    "    xy = dt[class_member_mask & core_samples_mask]\n",
    "    plt.plot(xy[:, 0], xy[:, 1], 'o', markerfacecolor=tuple(col),\n",
    "             markeredgecolor='k', markersize=14)\n",
    "\n",
    "    xy = dt[class_member_mask & ~core_samples_mask]\n",
    "    plt.plot(xy[:, 0], xy[:, 1], 'o', markerfacecolor=tuple(col),\n",
    "             markeredgecolor='k', markersize=6)\n",
    "\n",
    "plt.title('Estimated number of clusters: %d' % n_clusters_)\n",
    "#ax.scatter(xy[:, 0], xy[:, 1], xy[:, 0], c = labels)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline\n",
    "from sklearn.cluster import DBSCAN\n",
    "from sklearn import metrics\n",
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.cm as cmx\n",
    "import matplotlib\n",
    "\n",
    "colorsMap='jet'\n",
    "cm = plt.get_cmap(colorsMap)\n",
    "scalarMap = cmx.ScalarMappable(cmap=cm)\n",
    "\n",
    "dt = np.array([[coor[1], coor[2], coor[3]] for coor in atoms])\n",
    "# Compute DBSCAN eps=1.6, min_samples=5 eucl\n",
    "# manh eps=3, min_samples=5\n",
    "\n",
    "db = DBSCAN(eps=2.165, min_samples=7, metric='euclidean', algorithm='kd_tree').fit(dt)\n",
    "core_samples_mask = np.zeros_like(db.labels_, dtype=bool)\n",
    "core_samples_mask[db.core_sample_indices_] = True\n",
    "labels = db.labels_\n",
    "\n",
    "# Number of clusters in labels, ignoring noise if present.\n",
    "n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)\n",
    "\n",
    "print('Estimated number of clusters: %d' % n_clusters_)\n",
    "# print(\"Homogeneity: %0.3f\" % metrics.homogeneity_score(labels_true, labels))\n",
    "# print(\"Completeness: %0.3f\" % metrics.completeness_score(labels_true, labels))\n",
    "# print(\"V-measure: %0.3f\" % metrics.v_measure_score(labels_true, labels))\n",
    "# print(\"Adjusted Rand Index: %0.3f\"\n",
    "#       % metrics.adjusted_rand_score(labels_true, labels))\n",
    "# print(\"Adjusted Mutual Information: %0.3f\"\n",
    "#       % metrics.adjusted_mutual_info_score(labels_true, labels))\n",
    "# print(\"Silhouette Coefficient: %0.3f\"\n",
    "#       % metrics.silhouette_score(X, labels))\n",
    "\n",
    "xs = dt[:, 0]\n",
    "ys = dt[:, 1]\n",
    "zs = dt[:, 2]\n",
    "print(labels)\n",
    "\n",
    "#lbl = [0] * len(labels)\n",
    "#lbl[684] = 1\n",
    "fig = plt.figure(figsize=(10, 9))\n",
    "ax = Axes3D(fig, rect=[0, 0, .95, 1], elev=48, azim=134)\n",
    "ax.set_xlabel('x')\n",
    "ax.set_ylabel('y')\n",
    "ax.set_zlabel('z')\n",
    "ax.scatter3D(xs, ys, zs, c=scalarMap.to_rgba(labels))\n",
    "# fig.show()\n",
    "\n",
    "# plt.figure(figsize=(14, 9))\n",
    "# plt.scatter(xs, ys, c=labels)\n",
    "# #plt.interactive(True)\n",
    "# plt.show()\n",
    "\n",
    "# plt.figure(figsize=(14, 9))\n",
    "# plt.scatter(ys, zs, c=labels)\n",
    "# plt.show()\n",
    "\n",
    "# plt.figure(figsize=(14, 9))\n",
    "# plt.scatter(xs, zs, c=labels)\n",
    "# plt.show()\n",
    "\n",
    "# # #############################################################################\n",
    "\n",
    "# # Black removed and is used for noise instead.\n",
    "unique_labels = set(labels)\n",
    "colors = [plt.cm.Spectral(each)\n",
    "          for each in np.linspace(0, 1, len(unique_labels))]\n",
    "plt.figure(figsize=(10, 9))\n",
    "#ax = Axes3D(fig, rect=[0, 0, .95, 1], elev=48, azim=134)\n",
    "for k, col in zip(unique_labels, colors):\n",
    "    if k == -1:\n",
    "        # Black used for noise.\n",
    "        col = [0, 0, 0, 1]\n",
    "\n",
    "    class_member_mask = (labels == k)\n",
    "\n",
    "    xy = dt[class_member_mask & core_samples_mask]\n",
    "    plt.plot(xy[:, 0], xy[:, 1], 'o', markerfacecolor=tuple(col),\n",
    "             markeredgecolor='k', markersize=14)\n",
    "\n",
    "    xy = dt[class_member_mask & ~core_samples_mask]\n",
    "    plt.plot(xy[:, 0], xy[:, 1], 'o', markerfacecolor=tuple(col),\n",
    "             markeredgecolor='k', markersize=6)\n",
    "\n",
    "plt.title('Estimated number of clusters: %d' % n_clusters_)\n",
    "#ax.scatter(xy[:, 0], xy[:, 1], xy[:, 0], c = labels)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import random as pyrandom\n",
    "import sys, os\n",
    "nb_dir = os.path.split(os.getcwd())[0]\n",
    "if nb_dir not in sys.path:\n",
    "    sys.path.append(nb_dir)\n",
    "from parse_input import *\n",
    "\n",
    "import logging\n",
    "\n",
    "def setup_custom_logger(name):\n",
    "    formatter = logging.Formatter(fmt='%(asctime)s [%(levelname)-8s] %(message)s',\n",
    "                                  datefmt='%Y-%m-%d %H:%M:%S')\n",
    "    handler = logging.FileHandler('log.txt', mode='w')\n",
    "    handler.setFormatter(formatter)\n",
    "    screen_handler = logging.StreamHandler(stream=sys.stdout)\n",
    "    screen_handler.setFormatter(formatter)\n",
    "    logger = logging.getLogger(name)\n",
    "    logger.setLevel(logging.DEBUG)\n",
    "    logger.addHandler(handler)\n",
    "    logger.addHandler(screen_handler)\n",
    "    return logger\n",
    "\n",
    "logger = setup_custom_logger('parabola')\n",
    "\n",
    "# atoms.txt Содержит информацию об атомах, в колонках следующие данные:\n",
    "# ID, x, y, z, сигма, эпсилон, заряд, \n",
    "# радиус Ван-дер-Ваальса, объём и еще две колонки типа строки; \n",
    "# радиус и объем и эти две колонки не используются далее\n",
    "atoms = rd('atoms.txt', 1, 9)  # вместо 9 можно было и 7 взять\n",
    "\n",
    "# bonds.txt Содержит информацию о связях, структура файла:\n",
    "# ID1, ID2, Kr, r0\n",
    "bonds = rd('bonds.txt', 2)\n",
    "\n",
    "# angles.txt Содержит информацию об углах, структура файла:\n",
    "# ID1, ID2, ID3, Kt, theta0\n",
    "angles = rd('angles.txt', 3)\n",
    "\n",
    "# dihedrals.txt Содержит информацию о двугранных углах, структура:\n",
    "# ID1, ID2, ID3, ID4, V1, V2, V3, V4\n",
    "# Все константы V1, V2, V3, V4 разделены на два, \n",
    "# при вычислении энергии делить их на два НЕ НАДО.\n",
    "dihedrals = rd('dihedrals.txt', 4)\n",
    "\n",
    "# neighbours.txt, two_bonds_neigh.txt, three_bonds_neigh.txt\n",
    "# Содержат информацию о соседях непосредственных, \n",
    "# второго и третьего порядка соответственно. \n",
    "# У всех одна и та же структура:\n",
    "# ID    id_1 id_2 ... id_n\n",
    "# ID – индекс атома, id_1 id_2 ... id_n – индексы его соседей.\n",
    "neighbours = rd('neighbours.txt')\n",
    "two_bonds_neigh = rd('two_bonds_neigh.txt')\n",
    "\n",
    "three_bonds_neigh = rd('three_bonds_neigh.txt')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib %notebook\n",
    "from sklearn.cluster import DBSCAN\n",
    "from sklearn import metrics\n",
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.cm as cmx\n",
    "import matplotlib\n",
    "\n",
    "colorsMap='jet'\n",
    "cm = plt.get_cmap(colorsMap)\n",
    "scalarMap = cmx.ScalarMappable(cmap=cm)\n",
    "\n",
    "dt = np.array([[coor[1], coor[2], coor[3]] for coor in atoms])\n",
    "# Compute DBSCAN eps=1.6, min_samples=5 eucl\n",
    "# manh eps=3, min_samples=5\n",
    "\n",
    "db = DBSCAN(eps=2.165, min_samples=7, metric='euclidean', algorithm='kd_tree').fit(dt)\n",
    "core_samples_mask = np.zeros_like(db.labels_, dtype=bool)\n",
    "core_samples_mask[db.core_sample_indices_] = True\n",
    "labels = db.labels_\n",
    "\n",
    "# Number of clusters in labels, ignoring noise if present.\n",
    "n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)\n",
    "\n",
    "print('Estimated number of clusters: %d' % n_clusters_)\n",
    "# print(\"Homogeneity: %0.3f\" % metrics.homogeneity_score(labels_true, labels))\n",
    "# print(\"Completeness: %0.3f\" % metrics.completeness_score(labels_true, labels))\n",
    "# print(\"V-measure: %0.3f\" % metrics.v_measure_score(labels_true, labels))\n",
    "# print(\"Adjusted Rand Index: %0.3f\"\n",
    "#       % metrics.adjusted_rand_score(labels_true, labels))\n",
    "# print(\"Adjusted Mutual Information: %0.3f\"\n",
    "#       % metrics.adjusted_mutual_info_score(labels_true, labels))\n",
    "# print(\"Silhouette Coefficient: %0.3f\"\n",
    "#       % metrics.silhouette_score(X, labels))\n",
    "\n",
    "xs = dt[:, 0]\n",
    "ys = dt[:, 1]\n",
    "zs = dt[:, 2]\n",
    "print(labels)\n",
    "\n",
    "#lbl = [0] * len(labels)\n",
    "#lbl[684] = 1\n",
    "fig = plt.figure(figsize=(10, 9))\n",
    "ax = Axes3D(fig, rect=[0, 0, .95, 1], elev=48, azim=134)\n",
    "ax.set_xlabel('x')\n",
    "ax.set_ylabel('y')\n",
    "ax.set_zlabel('z')\n",
    "ax.scatter3D(xs, ys, zs, c=scalarMap.to_rgba(labels))\n",
    "# fig.show()\n",
    "\n",
    "# plt.figure(figsize=(14, 9))\n",
    "# plt.scatter(xs, ys, c=labels)\n",
    "# #plt.interactive(True)\n",
    "# plt.show()\n",
    "\n",
    "# plt.figure(figsize=(14, 9))\n",
    "# plt.scatter(ys, zs, c=labels)\n",
    "# plt.show()\n",
    "\n",
    "# plt.figure(figsize=(14, 9))\n",
    "# plt.scatter(xs, zs, c=labels)\n",
    "# plt.show()\n",
    "\n",
    "# # #############################################################################\n",
    "\n",
    "# # Black removed and is used for noise instead.\n",
    "unique_labels = set(labels)\n",
    "colors = [plt.cm.Spectral(each)\n",
    "          for each in np.linspace(0, 1, len(unique_labels))]\n",
    "plt.figure(figsize=(10, 9))\n",
    "#ax = Axes3D(fig, rect=[0, 0, .95, 1], elev=48, azim=134)\n",
    "for k, col in zip(unique_labels, colors):\n",
    "    if k == -1:\n",
    "        # Black used for noise.\n",
    "        col = [0, 0, 0, 1]\n",
    "\n",
    "    class_member_mask = (labels == k)\n",
    "\n",
    "    xy = dt[class_member_mask & core_samples_mask]\n",
    "    plt.plot(xy[:, 0], xy[:, 1], 'o', markerfacecolor=tuple(col),\n",
    "             markeredgecolor='k', markersize=14)\n",
    "\n",
    "    xy = dt[class_member_mask & ~core_samples_mask]\n",
    "    plt.plot(xy[:, 0], xy[:, 1], 'o', markerfacecolor=tuple(col),\n",
    "             markeredgecolor='k', markersize=6)\n",
    "\n",
    "plt.title('Estimated number of clusters: %d' % n_clusters_)\n",
    "#ax.scatter(xy[:, 0], xy[:, 1], xy[:, 0], c = labels)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "%notebook\n",
    "%matplotlib notebook\n",
    "from sklearn.cluster import DBSCAN\n",
    "from sklearn import metrics\n",
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.cm as cmx\n",
    "import matplotlib\n",
    "\n",
    "colorsMap='jet'\n",
    "cm = plt.get_cmap(colorsMap)\n",
    "scalarMap = cmx.ScalarMappable(cmap=cm)\n",
    "\n",
    "dt = np.array([[coor[1], coor[2], coor[3]] for coor in atoms])\n",
    "# Compute DBSCAN eps=1.6, min_samples=5 eucl\n",
    "# manh eps=3, min_samples=5\n",
    "\n",
    "db = DBSCAN(eps=2.165, min_samples=7, metric='euclidean', algorithm='kd_tree').fit(dt)\n",
    "core_samples_mask = np.zeros_like(db.labels_, dtype=bool)\n",
    "core_samples_mask[db.core_sample_indices_] = True\n",
    "labels = db.labels_\n",
    "\n",
    "# Number of clusters in labels, ignoring noise if present.\n",
    "n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)\n",
    "\n",
    "print('Estimated number of clusters: %d' % n_clusters_)\n",
    "# print(\"Homogeneity: %0.3f\" % metrics.homogeneity_score(labels_true, labels))\n",
    "# print(\"Completeness: %0.3f\" % metrics.completeness_score(labels_true, labels))\n",
    "# print(\"V-measure: %0.3f\" % metrics.v_measure_score(labels_true, labels))\n",
    "# print(\"Adjusted Rand Index: %0.3f\"\n",
    "#       % metrics.adjusted_rand_score(labels_true, labels))\n",
    "# print(\"Adjusted Mutual Information: %0.3f\"\n",
    "#       % metrics.adjusted_mutual_info_score(labels_true, labels))\n",
    "# print(\"Silhouette Coefficient: %0.3f\"\n",
    "#       % metrics.silhouette_score(X, labels))\n",
    "\n",
    "xs = dt[:, 0]\n",
    "ys = dt[:, 1]\n",
    "zs = dt[:, 2]\n",
    "print(labels)\n",
    "\n",
    "#lbl = [0] * len(labels)\n",
    "#lbl[684] = 1\n",
    "fig = plt.figure(figsize=(10, 9))\n",
    "ax = Axes3D(fig, rect=[0, 0, .95, 1], elev=48, azim=134)\n",
    "ax.set_xlabel('x')\n",
    "ax.set_ylabel('y')\n",
    "ax.set_zlabel('z')\n",
    "ax.scatter3D(xs, ys, zs, c=scalarMap.to_rgba(labels))\n",
    "# fig.show()\n",
    "\n",
    "# plt.figure(figsize=(14, 9))\n",
    "# plt.scatter(xs, ys, c=labels)\n",
    "# #plt.interactive(True)\n",
    "# plt.show()\n",
    "\n",
    "# plt.figure(figsize=(14, 9))\n",
    "# plt.scatter(ys, zs, c=labels)\n",
    "# plt.show()\n",
    "\n",
    "# plt.figure(figsize=(14, 9))\n",
    "# plt.scatter(xs, zs, c=labels)\n",
    "# plt.show()\n",
    "\n",
    "# # #############################################################################\n",
    "\n",
    "# # Black removed and is used for noise instead.\n",
    "unique_labels = set(labels)\n",
    "colors = [plt.cm.Spectral(each)\n",
    "          for each in np.linspace(0, 1, len(unique_labels))]\n",
    "plt.figure(figsize=(10, 9))\n",
    "#ax = Axes3D(fig, rect=[0, 0, .95, 1], elev=48, azim=134)\n",
    "for k, col in zip(unique_labels, colors):\n",
    "    if k == -1:\n",
    "        # Black used for noise.\n",
    "        col = [0, 0, 0, 1]\n",
    "\n",
    "    class_member_mask = (labels == k)\n",
    "\n",
    "    xy = dt[class_member_mask & core_samples_mask]\n",
    "    plt.plot(xy[:, 0], xy[:, 1], 'o', markerfacecolor=tuple(col),\n",
    "             markeredgecolor='k', markersize=14)\n",
    "\n",
    "    xy = dt[class_member_mask & ~core_samples_mask]\n",
    "    plt.plot(xy[:, 0], xy[:, 1], 'o', markerfacecolor=tuple(col),\n",
    "             markeredgecolor='k', markersize=6)\n",
    "\n",
    "plt.title('Estimated number of clusters: %d' % n_clusters_)\n",
    "#ax.scatter(xy[:, 0], xy[:, 1], xy[:, 0], c = labels)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "%notebook FEM8_local-checkpoint.ipynb\n",
    "%matplotlib notebook\n",
    "from sklearn.cluster import DBSCAN\n",
    "from sklearn import metrics\n",
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.cm as cmx\n",
    "import matplotlib\n",
    "\n",
    "colorsMap='jet'\n",
    "cm = plt.get_cmap(colorsMap)\n",
    "scalarMap = cmx.ScalarMappable(cmap=cm)\n",
    "\n",
    "dt = np.array([[coor[1], coor[2], coor[3]] for coor in atoms])\n",
    "# Compute DBSCAN eps=1.6, min_samples=5 eucl\n",
    "# manh eps=3, min_samples=5\n",
    "\n",
    "db = DBSCAN(eps=2.165, min_samples=7, metric='euclidean', algorithm='kd_tree').fit(dt)\n",
    "core_samples_mask = np.zeros_like(db.labels_, dtype=bool)\n",
    "core_samples_mask[db.core_sample_indices_] = True\n",
    "labels = db.labels_\n",
    "\n",
    "# Number of clusters in labels, ignoring noise if present.\n",
    "n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)\n",
    "\n",
    "print('Estimated number of clusters: %d' % n_clusters_)\n",
    "# print(\"Homogeneity: %0.3f\" % metrics.homogeneity_score(labels_true, labels))\n",
    "# print(\"Completeness: %0.3f\" % metrics.completeness_score(labels_true, labels))\n",
    "# print(\"V-measure: %0.3f\" % metrics.v_measure_score(labels_true, labels))\n",
    "# print(\"Adjusted Rand Index: %0.3f\"\n",
    "#       % metrics.adjusted_rand_score(labels_true, labels))\n",
    "# print(\"Adjusted Mutual Information: %0.3f\"\n",
    "#       % metrics.adjusted_mutual_info_score(labels_true, labels))\n",
    "# print(\"Silhouette Coefficient: %0.3f\"\n",
    "#       % metrics.silhouette_score(X, labels))\n",
    "\n",
    "xs = dt[:, 0]\n",
    "ys = dt[:, 1]\n",
    "zs = dt[:, 2]\n",
    "print(labels)\n",
    "\n",
    "#lbl = [0] * len(labels)\n",
    "#lbl[684] = 1\n",
    "fig = plt.figure(figsize=(10, 9))\n",
    "ax = Axes3D(fig, rect=[0, 0, .95, 1], elev=48, azim=134)\n",
    "ax.set_xlabel('x')\n",
    "ax.set_ylabel('y')\n",
    "ax.set_zlabel('z')\n",
    "ax.scatter3D(xs, ys, zs, c=scalarMap.to_rgba(labels))\n",
    "# fig.show()\n",
    "\n",
    "# plt.figure(figsize=(14, 9))\n",
    "# plt.scatter(xs, ys, c=labels)\n",
    "# #plt.interactive(True)\n",
    "# plt.show()\n",
    "\n",
    "# plt.figure(figsize=(14, 9))\n",
    "# plt.scatter(ys, zs, c=labels)\n",
    "# plt.show()\n",
    "\n",
    "# plt.figure(figsize=(14, 9))\n",
    "# plt.scatter(xs, zs, c=labels)\n",
    "# plt.show()\n",
    "\n",
    "# # #############################################################################\n",
    "\n",
    "# # Black removed and is used for noise instead.\n",
    "unique_labels = set(labels)\n",
    "colors = [plt.cm.Spectral(each)\n",
    "          for each in np.linspace(0, 1, len(unique_labels))]\n",
    "plt.figure(figsize=(10, 9))\n",
    "#ax = Axes3D(fig, rect=[0, 0, .95, 1], elev=48, azim=134)\n",
    "for k, col in zip(unique_labels, colors):\n",
    "    if k == -1:\n",
    "        # Black used for noise.\n",
    "        col = [0, 0, 0, 1]\n",
    "\n",
    "    class_member_mask = (labels == k)\n",
    "\n",
    "    xy = dt[class_member_mask & core_samples_mask]\n",
    "    plt.plot(xy[:, 0], xy[:, 1], 'o', markerfacecolor=tuple(col),\n",
    "             markeredgecolor='k', markersize=14)\n",
    "\n",
    "    xy = dt[class_member_mask & ~core_samples_mask]\n",
    "    plt.plot(xy[:, 0], xy[:, 1], 'o', markerfacecolor=tuple(col),\n",
    "             markeredgecolor='k', markersize=6)\n",
    "\n",
    "plt.title('Estimated number of clusters: %d' % n_clusters_)\n",
    "#ax.scatter(xy[:, 0], xy[:, 1], xy[:, 0], c = labels)\n",
    "plt.show()"
   ]
  }
 ],
 "metadata": {},
 "nbformat": 4,
 "nbformat_minor": 2
}
